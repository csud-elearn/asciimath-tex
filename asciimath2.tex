% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
 

\newlinechar=`@

% OK, change: need  to fully lex into a token register before outputting.
\newtoks\tempStrA
\def\appendToks#1#2{
    \tempStrA={#2}%
%    \message{Appending to \noexpand#1: [\the#1] plus [\the\tempStrA]@}
    \edef\tmpA{\the#1\the\tempStrA}%
    #1=\expandafter{\tmpA}%
}

\catcode96=13%
\def`{\setup\startParse}
\def\setup{
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
    %\defParenCmds
}

\newtoks\lexedTokens
\def\addLexed{\appendToks\lexedTokens}
\def\addBlock#1{\appendToks\lexedTokens{\block0{#1}}}

\def\startParse#1`{%
    %\message{Starting to lex:}
    \lexedTokens={}\lexTokens#1\end
    \message{The lexed tokens:}
    \showthe\lexedTokens
    \message{done.}
    \mathdelim\the\lexedTokens\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
% 
% TODO (maybe these shouldn't go here):
% * Register \sqrt (maybe that shouldn't go here?)
% * Try using operator precedence: a^2/b_3 == (a^2)/(b_3)
% * also a^2_1 should work better
%
\begingroup
\catcode32=13
%\catcode40=13
\gdef\sspaceB{ }
\gdef\sparenB{(}
\catcode32=10
\endgroup



% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\gdef\lexTokens#1{%
    \ifx#1\end\let\next=\relax
    %\message{About to test spaces...first is:}
    %\show#1%
    %\message{And second is:}
    %\show\sspaceB
    %\message{So there.}
    %\if\sspaceB\noexpand#1\message{YESYES}\else\message{NONO}\fi
    % the noexpand is necessary if eg we parse an active (.
    \else\if\sspaceB\noexpand#1\let\next=\lexTokens% ignore spaces
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS#1}%
    \else\ifcat\noexpand#1^\def\next{\addLexed{\binOp\Superscript}\lexTokens}%
    \else\ifcat\noexpand#1_\def\next{\addLexed{\binOp\Subscript}\lexTokens}%
    \else\ifcat\noexpand#1/\def\next{\processOtherChar#1}%
    \else\def\next{\addBlock#1\lexTokens}%
    \fi\fi\fi\fi\fi\fi
    \next
}%

\def\processOtherChar#1{%
    %\message{Processing otherchar:#1@}
    \ifx#1/\def\next{\addLexed{\binOp\fracOp}\lexTokens}%
    \else\ifx#1(\def\next{\addLexed{\startParen}\lexTokens}%
    \else\ifx#1)\def\next{\addLexed{\endParen}\lexTokens}%
    \else\ifx#1-\def\next{\scanMinusOrNeg}%
    % TODO: if it's a digit (or if it's a '-' and the next token's a digit
    % then read a number and turn it into a block.
    \else
        \ifisdigit#1{\def\next{\scanNumber{#1}}}
            {\def\next{\addBlock#1\lexTokens}}%
    \fi\fi\fi\fi
    \next
}

% There must be a more efficient way to do this...
\newif\ifisDigitCond
\def\ifisdigit#1#2#3{
    \isDigitCondfalse
    \ifx0#1\isDigitCondtrue\fi
    \ifx1#1\isDigitCondtrue\fi
    \ifx2#1\isDigitCondtrue\fi
    \ifx3#1\isDigitCondtrue\fi
    \ifx4#1\isDigitCondtrue\fi
    \ifx5#1\isDigitCondtrue\fi
    \ifx6#1\isDigitCondtrue\fi
    \ifx7#1\isDigitCondtrue\fi
    \ifx8#1\isDigitCondtrue\fi
    \ifx9#1\isDigitCondtrue\fi
    \ifisDigitCond#2\else#3\fi
}

\def\scanNumber#1{\def\todo{\scanNumberA{#1}}\futurelet\nextTok\todo}
\def\scanNumberA#1{%
    \ifisdigit\nextTok{\def\next##1{\scanNumber{#1##1}}}%
        {\def\next{\addBlock{#1}\lexTokens}}
    \next
}

% scanned a '-'; need to peek one more to check if this starts a negative number.
\def\scanMinusOrNeg{\futurelet\nextTok\scanMinusOrNegA}
\def\scanMinusOrNegA{%
    \ifisdigit\nextTok
        {\def\next{\scanNumber{-}}}%
        {\def\next{\addBlock{-}\lexTokens}}%
    \next
}

%%%%%%%%%%%
% binary operations
\def\fracOp#1#2{%
    {#1\over#2}%
}
\def\Superscript#1#2{%
    {#1}^{#2}%
}
\def\Subscript#1#2{%
    {#1}_{#2}%
}

\newtoks\csNameStr
\def\parseLetterOrCS#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\nextTok a\def\next{\csNameStr={#1}\parseCS}%
                \else\def\next{\addBlock#1\lexTokens}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS{\futurelet\nextTok\parseCSa}
\def\parseCSa{%
    \ifcat\nextTok a\def\next{\addToCSAndCont}%
    \else\def\next{\emitCSAndLex}%
    \fi\next
}
\def\addToCSAndCont#1{%
    \appendToks\csNameStr#1%\edef\next{\noexpand\csNameStr={\the\csNameStr#1}}%
    \parseCS
}
\def\emitCSAndLex{%
    \edef\nextL{\the\csNameStr}
    \expandafter\expandafter\expandafter\addBlock\expandafter\csname\nextL\endcsname\lexTokens
    %\edef\nextL{\csname\the\csNameStr\endcsname}%
    %\expandafter\addLexed\nextL\lexTokens
}

%%%%%%%%%%%%%%
%% Building from blocks
% 
% OK, the lexer's done.  First up: startParen, which just expands
% into a \block1.

\newtoks\parenContents
\newcount\parenLevel


\def\startParen{\scanParenWrap\blockedParenContents}
\def\scanParenWrap#1{%
    \parenLevel=0\parenContents={}\scanParenBlock#1%
}
\def\scanParenBlock#1{\def\todo{\scanParenBlockA{#1}}\futurelet\nextTok\todo}
% Need to check for '{' b/c it's output by numbers...
\def\scanParenBlockA#1{%
    %\message{Checking if upcoming brace...@}
    %\show\bgroup
    %\show\nextTok
    \ifx\bgroup\nextTok
        \def\next{\scanBracedAndCont{#1}}%
    \else\def\next{\scanParenBlockB{#1}}%
    \fi\next
}
\def\scanBracedAndCont#1#2{%
    \appendToks\parenContents{{#2}}%
    \scanParenBlock#1%
}
% next is a single token, read it.
\def\scanParenBlockB#1#2{%
    \ifx#2\endParen
        \ifnum\parenLevel>0%
            \advance\parenLevel by -1%
            \def\next{\appendToks\parenContents{#2}\scanParenBlock#1}%
        \else\let\next=#1
        \fi
    \else
        \ifx#2\startParen\advance\parenLevel by 1%
        \fi
        \appendToks\parenContents{#2}%
        \def\next{\scanParenBlock#1}
    \fi
    \next
}
\def\blockedParenContents{%
    \expandafter\block\expandafter1\expandafter{\the\parenContents}%
}

% TODO: for now, don't worry about parens in denominator.

% Next, block checks whether it's followed by a binOp.  If not, just output.
% Otherwise, pass into the binOp.
\def\block#1#2{%
    \tempStrA={#1,#2}
    %\message{Outputting block [#1]: \the\tempStrA@}
    %\ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
    \def\todo{\blockA#1{#2}}\futurelet\nextTok\todo
}
\def\blockA#1#2{%
    \ifx\nextTok\binOp\def\next{\runBinOp{#2}}%
    \else\def\next{\outputPlain#1{#2}}%
    \fi
    \next
}
\def\outputPlain#1#2{%
    \ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
}
\newtoks\tempStrB
\newtoks\tempStrC

\def\runBinOp#1\binOp#2#3{
    \ifx#3\block\def\next##1##2{\block0{#2{#1}{##2}}}
    \else\ifx#3\startParen\def\next{%
                    \def\useParen{\parenDenom{#1}{#2}}
                    \scanParenWrap\useParen
                }%
    \else\def\next{\message{Sorry, I can't handle this type:\noexpand#3}\end}%
    \fi\fi
    \next
}

\def\parenDenom#1#2{%
    \edef\todo{\noexpand\block0{\noexpand#2{#1}{\the\parenContents}}}%
    \todo
}

%% hack for now; assume denom is simple block:
%\def\runBinOp#1\binOp#2\block0#3{%
%    \tempStrB={#1,#2,#3}
%    \message{RunBinOp:\the\tempStrB@}
%    #2{#1}{#3}%
%}

% For testing:
\def\binOp#1{\message{binOp: Something went wrong...\noexpand#1@}}


%%%%%%%%%%%%%%%%%%%%
% Examples
\def\startTrace{\message{Starting trace...@}%
    \tracingmacros=2\tracingassigns=2\tracingcommands=0%
}
\def\endTrace{\message{Ending trace...}\tracingmacros=0\tracingassigns=0\tracingcommands=0}


% TODO: frac is being expanded too early...
%` startTrace (alpha(frac2)) endTrace`
, `(9)`
, `(9^-74)`
`3^2`
% TODO: DO put parens around frac when it's exponentiated.
, `125^-74`
, `1/125^74`
, `1-a`


$$` 2/3 + ((alpha+2)/2 * 5)/7`$$

`2/3/3`

$$` z/((q*(2/beta to gamma)))`$$

` alpha^(2+3)/5`

`a^1_2`

\bye
