% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
% 
% OLD VERSION:
% OK, let's try without having spaces be tokens:
% Only issue is braces...
% Given a list of previously stored blocks:
% Peek 

% Separate into two parts:
% First, set spaces to active so they can be easily eaten
% Then, parse the characters inside of the `...` .  
% Now, all spaces read are active.
\catcode96=13%
\def`{\setup\startParse}
\def\setup{
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
}
\def\startParse#1`{%
    \mathdelim\lexTokens#1\end\mathdelim\endgroup}

% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\def\lexTokens#1{%
    \ifx#1\end\let\next=\relax
    \else\ifcat#1\sspace\let\next=\lexTokens% ignore spaces
    \else\ifcat#1a\def\next{\parseLetterOrCS#1}%
    \else\def\next{#1\lexTokens}%
    \fi\fi\fi
    \next
}

\newtoks\csNameStr
\def\parseLetterOrCS#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\nextTok a\def\next{\csNameStr={#1}\parseCS}%
                \else\def\next{#1\lexTokens}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS{\futurelet\nextTok\parseCSa}
\def\parseCSa{%
    \ifcat\nextTok a\def\next{\addToCSAndCont}%
    \else\def\next{\emitCSAndLex}
    \fi\next
}
\def\addToCSAndCont#1{%
    \edef\next{\noexpand\csNameStr={\the\csNameStr#1}}%
    \next\parseCS
}
\def\emitCSAndLex{%
    \edef\next{\noexpand\csname\the\csNameStr
                    \noexpand\endcsname}%
    \next\lexTokens
}


\tracingmacros=1
\tracingassigns=1
\tracingcommands=1

`  beta x  (`


\tracingmacros=0
\tracingassigns=0

\bye
