% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
% 
% OLD VERSION:
% OK, let's try without having spaces be tokens:
% Only issue is braces...
% Given a list of previously stored blocks:
% Peek 

% Separate into two parts:
% First, set spaces to active so they can be easily eaten
% Then, parse the characters inside of the `...` .  
% Now, all spaces read are active.

% OK, change: need  to fully lex into a token register before outputting.
\def\appendTok#1#2{\edef\next{\noexpand#1={\the#1\noexpand#2}}\next}

\catcode96=13%
\def`{\setup\startParse}
\def\setup{
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
    \defParenCmds
}

\newtoks\lexedTokens
\def\addLexed{\appendTok\lexedTokens}

\def\startParse#1`{%
    \lexedTokens={}\lexTokens#1\end
    \message{The lexed tokens:}
    \showthe\lexedTokens
    \message{done.}
    \mathdelim\the\lexedTokens\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
%
\begingroup
\catcode32=13
\catcode40=13
\gdef\sspaceB{ }
\gdef\sparenB{(}
\catcode32=10
\endgroup



% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\gdef\lexTokens#1{%
    \ifx#1\end\let\next=\relax
    \else
    %\message{About to test spaces...first is:}
    %\show#1%
    %\message{And second is:}
    %\show\sspaceB
    %\message{So there.}
    %\if\sspaceB\noexpand#1\message{YESYES}\else\message{NONO}\fi
    % the noexpand is necessary if eg we parse an active (.
    \if\sspaceB\noexpand#1\let\next=\lexTokens% ignore spaces
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS#1}%
    \else\def\next{\addLexed#1\lexTokens}%
    \fi\fi\fi
    \next
}%

\newtoks\csNameStr
\def\parseLetterOrCS#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\nextTok a\def\next{\csNameStr={#1}\parseCS}%
                \else\def\next{\addLexed#1\lexTokens}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS{\futurelet\nextTok\parseCSa}
\def\parseCSa{%
    \ifcat\nextTok a\def\next{\addToCSAndCont}%
    \else\def\next{\emitCSAndLex}%
    \fi\next
}
\def\addToCSAndCont#1{%
    \appendTok\csNameStr#1%\edef\next{\noexpand\csNameStr={\the\csNameStr#1}}%
    \next\parseCS
}
\def\emitCSAndLex{%
    \edef\nextL{\the\csNameStr}
    \expandafter\expandafter\expandafter\addLexed\expandafter\csname\nextL\endcsname\lexTokens
    %\edef\nextL{\csname\the\csNameStr\endcsname}%
    %\expandafter\addLexed\nextL\lexTokens
}


%%%%%%%%%%%%%%%%%%%%
% Parentheses

\begingroup
\catcode40=\active
\gdef\defParenCmds{%
    \def\lparen{\char40}%
    \catcode40=13%
    \let(=\parenWrap
}
\endgroup



\newtoks\parenContents
\newcount\parenLevel

% TODO: handle braces.
\begingroup
\catcode40=13
\gdef\parenWrap{\parenLevel=0\parenContents={}\buildList}
\gdef\buildList#1{%
    \ifx#1)\ifnum\parenLevel>0\def\next{\advance\parenLevel-1%
                                \appendTok\parenContents#1\buildList}
            \else\let\next=\useParenContents\fi
    \else\ifx#1(\advance\parenLevel by 1\fi
        \def\next{\appendTok\parenContents#1\buildList}%
    \fi
    \next
}
\endgroup

\def\useParenContents{\left(\the\parenContents\right)} % TODO




%%%%%%%%%%%%%%%%%%%%
% Examples
\def\startTrace{\message{Starting trace...}\tracingmacros=2\tracingassigns=2\tracingcommands=2}
\def\endTrace{\message{Ending trace...}\tracingmacros=0\tracingassigns=0\tracingcommands=0}


% TODO: frac is being expanded too early...
\def\frac{{2\over\alpha}}
\def\fracfrac{{2^{10}\over\alpha}}
` startTrace ((frac2)) endTrace`

\bye
