% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
 

\newlinechar=`@

% OK, change: need  to fully lex into a token register before outputting.
\newtoks\tempStrA
\def\appendToks#1#2{
    \tempStrA={#2}%
%    \message{Appending to \noexpand#1: [\the#1] plus [\the\tempStrA]@}
    \edef\tmpA{\the#1\the\tempStrA}%
    #1=\expandafter{\tmpA}%
}

\catcode96=13%
\def`{\setup\startParse}
\def\setup{
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
    %\defParenCmds
}

\newtoks\lexedTokens
\def\addLexed{\appendToks\lexedTokens}
\def\addBlock#1{\appendToks\lexedTokens{\block0{#1}}}

\def\startParse#1`{%
    %\message{Starting to lex:}
    \lexedTokens={}\lexTokens#1\end
    %\message{The lexed tokens:}
    \showthe\lexedTokens
    %\message{done.}
    \mathdelim\the\lexedTokens\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
% 
% TODO:
% * Support ^,_
% * Register \sqrt (maybe that shouldn't go here?)
%
\begingroup
\catcode32=13
%\catcode40=13
\gdef\sspaceB{ }
\gdef\sparenB{(}
\catcode32=10
\endgroup



% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\gdef\lexTokens#1{%
    \ifx#1\end\let\next=\relax
    \else
    %\message{About to test spaces...first is:}
    %\show#1%
    %\message{And second is:}
    %\show\sspaceB
    %\message{So there.}
    %\if\sspaceB\noexpand#1\message{YESYES}\else\message{NONO}\fi
    % the noexpand is necessary if eg we parse an active (.
    \if\sspaceB\noexpand#1\let\next=\lexTokens% ignore spaces
    \else\ifx#1/\def\next{\addLexed{\binOp\frac}\lexTokens}%
    \else\ifx#1(\def\next{\addLexed{\startParen}\lexTokens}%
    \else\ifx#1)\def\next{\addLexed{\endParen}\lexTokens}%
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS#1}%
    \else\def\next{\addBlock#1\lexTokens}%
    \fi\fi\fi\fi\fi\fi
    \next
}%

\newtoks\csNameStr
\def\parseLetterOrCS#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\nextTok a\def\next{\csNameStr={#1}\parseCS}%
                \else\def\next{\addBlock#1\lexTokens}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS{\futurelet\nextTok\parseCSa}
\def\parseCSa{%
    \ifcat\nextTok a\def\next{\addToCSAndCont}%
    \else\def\next{\emitCSAndLex}%
    \fi\next
}
\def\addToCSAndCont#1{%
    \appendToks\csNameStr#1%\edef\next{\noexpand\csNameStr={\the\csNameStr#1}}%
    \parseCS
}
\def\emitCSAndLex{%
    \edef\nextL{\the\csNameStr}
    \expandafter\expandafter\expandafter\addBlock\expandafter\csname\nextL\endcsname\lexTokens
    %\edef\nextL{\csname\the\csNameStr\endcsname}%
    %\expandafter\addLexed\nextL\lexTokens
}

%%%%%%%%%%%%%%
%% Building from blocks
% 
% OK, the lexer's done.  First up: startParen, which just expands
% into a \block1.

\newtoks\parenContents
\newcount\parenLevel


\def\startParen{\scanParenWrap\blockedParenContents}
\def\scanParenWrap#1{%
    \parenLevel=0\parenContents={}\scanParenBlock#1%
}
\def\scanParenBlock#1#2{%
    \ifx#2\endParen
        \ifnum\parenLevel>0%
            \advance\parenLevel by -1%
            \def\next{\appendToks\parenContents{#2}\scanParenBlock#1}%
        \else\let\next=#1
        \fi
    \else
        \ifx#2\startParen\advance\parenLevel by 1%
        \fi
        \appendToks\parenContents{#2}%
        \def\next{\scanParenBlock#1}
    \fi
    \next
}
\def\blockedParenContents{%
    \expandafter\block\expandafter1\expandafter{\the\parenContents}%
}

% TODO: for now, don't worry about parens in denominator.

% Next, block checks whether it's followed by a binOp.  If not, just output.
% Otherwise, pass into the binOp.
\def\block#1#2{%
    \tempStrA={#1,#2}
    %\message{Outputting block [#1]: \the\tempStrA@}
    %\ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
    \def\todo{\blockA#1{#2}}\futurelet\nextTok\todo
}
\def\blockA#1#2{%
    \ifx\nextTok\binOp\def\next{\runBinOp{#2}}%
    \else\def\next{\outputPlain#1{#2}}%
    \fi
    \next
}
\def\outputPlain#1#2{%
    \ifnum#1=0{#2}\else{{\left(#2\right)}}\fi
}
\newtoks\tempStrB
\newtoks\tempStrC

\def\runBinOp#1\binOp#2#3{
    \ifx#3\block\def\next##1##2{\block0{#2{#1}{##2}}}
    \else\ifx#3\startParen\def\next{%
                    \def\useParen{\parenDenom{#1}{#2}}
                    \scanParenWrap\useParen
                }%
    \else\def\next{\message{Sorry, I can't handle this type:\noexpand#3}\end}%
    \fi\fi
    \next
}

\def\parenDenom#1#2{%
    \edef\todo{\noexpand\block0{\noexpand#2{#1}{\the\parenContents}}}%
    \todo
}

%% hack for now; assume denom is simple block:
%\def\runBinOp#1\binOp#2\block0#3{%
%    \tempStrB={#1,#2,#3}
%    \message{RunBinOp:\the\tempStrB@}
%    #2{#1}{#3}%
%}

% For testing:
\def\binOp#1{\message{binOp: Something went wrong...\noexpand#1@}}


%%%%%%%%%%%%%%%%%%%%
% Examples
\def\startTrace{\message{Starting trace...@}%
    \tracingmacros=2\tracingassigns=2\tracingcommands=0%
}
\def\endTrace{\message{Ending trace...}\tracingmacros=0\tracingassigns=0\tracingcommands=0}


% TODO: frac is being expanded too early...
\def\frac#1#2{%
    {#1\over#2}%
}
%` startTrace (alpha(frac2)) endTrace`

` 3/5`

$$` 2/3 + ((alpha+2)/2 * 5)/7`$$

`2/3/3`

\startTrace
$$` z/((q*(2/beta gamma)))`$$
\endTrace

\bye
