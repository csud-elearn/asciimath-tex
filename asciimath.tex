
\def\app#1#2\to#3{\let#1=#3 #2}

\def\usePeek#1#2{\def\todo{\app#1{#2}\to\nextToken}\futurelet\nextToken\todo}

%\def\ifLetterIsNext#1\else#2\fi{\usePeek\foo{%
%    \ifcat\foo a\def\next{#1}\else\def\next{#2}\fi\next}}

% eg \peekNext\temp{do some stuff}
\def\peekNext#1#2{\def\nextA{#2}\futurelet#1\nextA}
\def\ifLetterIsNext#1\else#2\fi{%
    \peekNext\nextLetter{\ifcat\nextLetter a\def\nextB{#1}\else\def\nextB{#2}\fi\nextB}}

%\def\ifLetterIsNext#1\else#2\fi{%
%    \def\todo{\ifcat\nextToken z\def\next{#1}\else\def\next{#2}\fi\next}%
%    \futurelet\nextToken\todo}

% Expands the upcoming sequence of letters.  (Assuming there's at least one.)
% If there's only one letter, we keep it as a letter.
% If there's more than one, we turn it into a token.
% Using this: (YES, more tex-y than my lambdas)
% \def\cont#1{#1\doMoreStuff}
% \expandafter\cont\mycsname
% But if it's only one letter, don't bother. (TODO)
\def\mycsname#1{%
    \ifLetterIsNext\mycsnameloop{#1}\else#1\fi
}
\def\mycsnameloop#1{
    \ifLetterIsNext\moreloop{#1}
    \else\csname#1\endcsname\fi
}
\def\moreloop#1#2{\mycsnameloop{#1#2}}

% when running csnamer, put the TODO macro in \csuser
\def\csnamer#1{%
    \ifLetterIsNext\csnamerloop{#1}\else\csuser#1\fi
}
\def\csnamerloop#1{
    \ifLetterIsNext\moreLooper{#1}
    \else\expandafter\csuser\csname#1\endcsname\fi
}
\def\moreLooper#1#2{\csnamerloop{#1#2}}

%%%%%%
% parentheses
% put the ``todo'' in \useParens
% Use as: \let\useParens=..\parseParens(...)
%
% First, no nesting.
% Then, count parens and only end when at zero level.
% (This is not efficient, but whatever.)
\newcount\parenNest
\def\parseParens#1{\parenNest=0\buildList}
\def\buildList#1#2{%
    \ifx#2)\ifnum\parenNest>0\def\next{\advance\parenNest-1\buildList{#1#2}}%
            \else\def\next{\useParens{#1}}\fi%
    \else\ifx#2(\advance\parenNest by 1\fi
        \def\next{\buildList{#1#2}}\fi
    \next
}

\def\parenWrap#1{\left(#1\right)}


%%%%%
% TODO: can't handle braces.
% TODO: parens, fractions, etc.
\catcode96=13%
\def`#1`{
\begingroup
\catcode32=\active
\ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
\def\useASCII##1{\mathdelim##1\mathdelim\endgroup}
\scanASCII{#1}
}
\def\scanASCII#1{\loopASCII{}#1\end}
\def\loopASCII#1{\def\next{\loopASCIIa{#1}}\futurelet\nextToken\next}
\def\loopASCIIa#1{%
    \ifx\nextToken\end\def\nextC{\useASCII{#1}}%
    \else\ifcat\nextToken a\def\nextC{%
        \def\csuser####1{\loopASCII{#1####1}}\csnamer}%
    \else\ifx\nextToken(\def\nextC{%
        \def\useParens####1{
            \bgroup\def\useASCII########1{
                \egroup\loopASCII{#1\parenWrap{########1}}}
            \scanASCII{####1}}%
        \parseParens}%
    \else\def\nextC##1{\loopASCII{#1##1}}%
    \fi\fi\fi\nextC
}

% Read a paren'd list (counting nesting to make sure we're right),
% scan with scanASCII, then loop with that amount.

Stuff

Some stuff

%One \mycsname par abc

\tracingmacros=2
\tracingassigns=2

%\tracingcommands=2

`+(alpha*\Sigma (2/gamma)beta)`
\tracingmacros=0
\tracingassigns=0

\bye
