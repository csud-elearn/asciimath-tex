\NeedsTeXFormat{LaTeX2e}[1994/12/01]
\ProvidesPackage{asciimth}[2009/12/11 v0.1 ASCIIMath support for LaTeX]

\makeatletter

% OK, new idea:
% Step 1: do a ``lexer'' pass on the list which tokenizes sequences of letters and
% removes all spaces.
% Step 2: begingroup, then Make ``(^_/'' active.
%         (will need to first set \plainlparen, etc. macros to be used later.)
% Step 3: output the list, followed by an endgroup.
%
% The def of left parentheses is:
% - read the whole nested parens block
% - if next token is a ^,_ or /, output as {...};
%   otherwise output as {\left(...\right)}.
%
% The def of ^ is:
% read one character.  
%
% Also redef \sqrt to check if it's followed by a (...), and if so to read that block
% and do \plainSqrt{...}.
 

\def\appendToks@#1#2{%
    \edef\tmpA{\the#1}%
    #1=\expandafter{\tmpA#2}%
}

\catcode96=13%
\def`{%
    \setupASCII@
    \ifNextTokIs@`%
        {\endgroup \char96\char96}%
        {\startParse@}%
}
\def\setupASCII@{%
    \begingroup
    \catcode32=\active
    \def\sspace{ }% Do it here so the inside space is lexed as active
    \ifmmode\let\mathdelim=\relax\else\let\mathdelim=$\fi
    % def ^,_,/ and (
    % def sqrt et al
    %\defParenCmds
    \defineTokTypes@
}

\newtoks\lexedTokens@
\def\addLexed@{\appendToks@\lexedTokens@}
\def\addBlock@#1{\addLexed@{\block0{}{#1}}}

% TODO: what's the right thing to do here?
% LaTeX redefines \end so I can't use it here...but startParse seems like a poor
% choice.
\def\startParse@#1`{%
    \lexedTokens@={}\lexTokens@#1\startParse@
    \mathdelim\the\lexedTokens@\mathdelim
    \endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lexing
% 
% TODO (maybe these shouldn't go here):
% * Register \sqrt (maybe that shouldn't go here?)
% * Try using operator precedence: a^2/b_3 == (a^2)/(b_3)
% * also a^2_1 should work better
%
\begingroup
\catcode32=13
%\catcode40=13
\gdef\sspace@{ }
\endgroup

% TODO handle braces correctly
% Idea: temp turn them into active chars.
% (eventually might actually want this...)
\gdef\lexTokens@#1{%
    % ???? TODO ????
    \ifx#1\startParse@\let\next=\relax
    %\message{About to test spaces...first is:}
    %\show#1%
    %\message{And second is:}
    %\show\sspaceB
    %\message{So there.}
    %\if\sspaceB\noexpand#1\message{YESYES}\else\message{NONO}\fi
    % the noexpand is necessary if eg we parse an active (.
    \else\if\sspace@\noexpand#1\let\next=\lexTokens@% ignore spaces
    \else\ifcat\noexpand#1a\def\next{\parseLetterOrCS@#1}%
    \else\ifcat\noexpand#1^\def\next{\addLexed@{^}\lexTokens@}%
    \else\ifcat\noexpand#1_\def\next{\addLexed@{_}\lexTokens@}%
    \else\ifcat\noexpand#1/\def\next{\processOtherChar@#1}%
    \else\def\next{\addBlock@{#1}\lexTokens@}%
    \fi\fi\fi\fi\fi\fi
    \next
}%

\def\processOtherChar@#1{%
    \ifx#1/\let\next=\scanFracOrDiv@
    \else\ifx#1(\def\next{\addLexed@{\startParen(}\lexTokens@}%
    \else\ifx#1[\def\next{\addLexed@{\startParen[}\lexTokens@}%
    \else\ifx#1)\def\next{\addLexed@{\endParen)}\lexTokens@}%
    \else\ifx#1]\def\next{\addLexed@{\endParen]}\lexTokens@}%
    \else\ifx#1-\def\next{\addLexed@{-}\lexTokens@}%
    % TODO: if it's a digit (or if it's a '-' and the next token's a digit
    % then read a number and turn it into a block.
    \else
        \ifisdigitchar@#1{\def\next{\scanNumber@{#1}}}%
            {\def\next{\addBlock@{#1}\lexTokens@}}%
    \fi\fi\fi\fi\fi\fi
    \next
}

\def\scanFracOrDiv@{\futurelet\nextTok\scanFracOrDivA@}
\def\scanFracOrDivA@{%
    \ifx\nextTok/\def\next##1{\addBlock@{/}\lexTokens@}%
    \else\def\next{\addLexed@{/}\lexTokens@}%
    \fi
    \next
}

% There must be a more efficient way to do this...
\newif\ifisDigitCharCond@
\def\ifisdigitchar@#1#2#3{%
    \isDigitCharCond@false
    \ifx0#1\isDigitCharCond@true\fi
    \ifx1#1\isDigitCharCond@true\fi
    \ifx2#1\isDigitCharCond@true\fi
    \ifx3#1\isDigitCharCond@true\fi
    \ifx4#1\isDigitCharCond@true\fi
    \ifx5#1\isDigitCharCond@true\fi
    \ifx6#1\isDigitCharCond@true\fi
    \ifx7#1\isDigitCharCond@true\fi
    \ifx8#1\isDigitCharCond@true\fi
    \ifx9#1\isDigitCharCond@true\fi
    \ifisDigitCharCond@#2\else#3\fi
}

\def\scanNumber@#1{\def\todo{\scanNumberA@{#1}}\futurelet\nextTok\todo}
\def\scanNumberA@#1{%
    \ifisdigitchar@\nextTok{\def\next##1{\scanNumber@{#1##1}}}%
        {\def\next{\addBlock@{#1}\lexTokens@}}%
    \next
}

\newtoks\csNameStr@
\def\parseLetterOrCS@#1{%
    % First check whether the next unparsed token is a letter.
    \def\todo{\ifcat\noexpand\nextTok a\def\next{\csNameStr@={#1}\parseCS@}%
                \else\def\next{\addBlock@#1\lexTokens@}\fi\next}%
    \futurelet\nextTok\todo
}
\def\parseCS@{\futurelet\nextTok\parseCSa@}
\def\parseCSa@{%
    \ifcat\noexpand\nextTok a\let\next=\addToCSAndCont@%
    \else\let\next=\emitCSAndLex@%
    \fi\next
}
\def\addToCSAndCont@#1{%
    \appendToks@\csNameStr@#1%
    \parseCS@
}

\def\sqrtString@{sqrt}%
\def\emitCSAndLex@{%
    \edef\scannedStr{\the\csNameStr@}%
    \ifx\sqrtString@\scannedStr
        \def\next{\addLexed@{\sqrtT}\lexTokens@}%
    \else
        \def\next{%
            \expandafter\expandafter\expandafter
                \addBlock@\expandafter\csname\scannedStr\endcsname
            \lexTokens@
        }%
    \fi\next
}

%%%%%%%%%%%%%%
%% Parsing lexed tokens into a large structure
%
% Grammar is:
% 
% E ->  O E  | <empty>
% O ->  S    | S / S
% S ->  T    | T^Tm  | T_T   | T_T^Tm
% Tm -> T | -T
% T -> <block> or (E) | sqrt T
%
% We handle the recursion by just accumulating the unexpanded inside
% and later outputting it inside of parens, \frac, etc.
% In particular, readO is NOT a recursive macro.
%
% Objects inside are:
% Raw operations /,^,_,-
% \block#1#2#3: #1 is 1 if this should be wrapped with parens when not a
%                   subexpr of a fraction, exponent, etc., and 0 otherwise.
%               #2 is eg "()" or "[)" if this should be wrapped
%               #3 is the internals of the block.
% \startParen#1: #1 is '(', '[', etc.
% \endParen#1: #1 is ')', ']', etc.
% 
% We also provide for other macros like \blockSqrt.  When it appears, it
% parses the upcoming block and expands into another block.

% When we get to an unprocessed block, we should start the parsing process over
% again.
\def\defineTokTypes@{%
    \def\block{\readO@\block}%
    \def\startParen{\readO@\startParen}%
    \def\sqrtT{\readO@\sqrtT}%
}


\def\readO@{\let\useS=\maybeDoFraction@\readS@}
\def\maybeDoFraction@#1#2#3{%
    \ifNextTokIs@/{\readFraction@{#3}}{\putBlock@#1{#2}{#3}}%
}

% Checks whether the next token is #1.  If so, eats it and runs #2.
% Otherwise, leaves it alone and runs #3.
\def\ifNextTokIs@#1#2#3{%
    \def\todo{\ifx#1\nextTok\def\next####1{#2}\else\def\next{#3}\fi\next}%
    \futurelet\nextTok\todo
}
        
% Given the numerator to a fraction (#1)
% parses the next S and returns the resulting fraction.
\def\readFraction@#1{%
    \def\useS##1##2##3{{#1\over##3}}%
    \readS@
}

% Reads an S nonterminal and passes the result to useS.
\def\readS@{%
    \def\useT##1##2##3{%
        \ifNextTokIs@_%
            {\doSubscript@{\putBlock@##1{##2}{##3}}}%
            {\ifNextTokIs@^%
                {\doSupscript@{\putBlock@##1{##2}{##3}}}%
                {\useS##1{##2}{##3}}}%
    }
    \readT@
}
\def\doSubscript@#1{%
    \def\useT##1##2##3{%
        \ifNextTokIs@^%
            {\doSupscript@{#1_{##3}}}%
            {\useS0{}{#1_{##3}}}%
    }\readT@
}
% First, read an optional minus sign.
\def\doSupscript@#1{%
    \ifNextTokIs@-%
        {\doSupscriptA@1{#1}}%
        {\doSupscriptA@0{#1}}%
}
\def\doSupscriptA@#1#2{%
    \ifx1#1% minus sign
        \def\useT##1##2##3{%
            \useS0{}{#2^{-\putBlock@##1{##2}{##3}}}%
        }%
    \else
        \def\useT##1##2##3{%
            \useS0{}{#2^{##3}}%
        }%
    \fi
    \readT@
}


\def\putBlock@#1#2#3{%
    \ifx0#1\def\next{{#3}}%
    \else\def\next{{\wrapBlock@#2{#3}}}%
    \fi\next
}
% Separate function to split apart the left and right paren chars.
\def\wrapBlock@#1#2#3{\left#1#3\right#2}

% Reads a "T" terminal (a lone block or a parenthesized expression)
% and then passes it as an argument to \useT.
\def\readT@#1{%
    \ifx#1\block\let\next=\readTBlock@
    \else\ifx#1\startParen\let\next=\readTParen@
    \else\ifx#1\sqrtT\let\next=\readSqrtT@
    \else\def\next{\message{Oops: ran into a non-block:\noexpand#1}\end}%
    \fi\fi\fi
    % TODO: sqrt causes us to read another T.
    \next
}

% OK, this is a little tricky b/c we need to keep the old version of useT.
\def\readSqrtT@{
    \bgroup
    \def\useT##1##2##3{%
        \egroup
        \useT0{}{\sqrt{##3}}%
    }%
    \readT@
}
        


\newtoks\parenContents@
\newcount\parenLevel@

\def\readTBlock@#1#2#3{\useT#1{#2}{#3}}
\def\readTParen@#1{%
    \def\parenStarter{#1}%
    \parenLevel@=0\parenContents@={}%
    \scanParenBlock@
}
% Need to check whether a '{' is next (e.g. lexing numbers produces it)
\def\scanParenBlock@{\futurelet\nextTok\scanParenBlockA@}
\def\scanParenBlockA@{%
    \ifx\bgroup\nextTok\let\next=\scanBraced@
    \else\let\next=\scanParenBlockB@
    \fi\next
}
\def\scanBraced@#1{%
    \appendToks@\parenContents@{{#1}}
    \scanParenBlock@
}
\def\scanParenBlockB@#1{%
    \ifx#1\endParen
        \ifnum0<\parenLevel@
            \def\next{
                \advance\parenLevel@ by -1%
                \appendToks@\parenContents@{\endParen}
                \scanParenBlock@
            }%
        \else\def\next##1{%
                \edef\newStuff{%
                    1{\parenStarter##1}{\the\parenContents@}%
                }%
                \expandafter\useT\newStuff%
            }%
        \fi
    \else
        \ifx#1\startParen\advance\parenLevel@ by 1\fi
        \appendToks@\parenContents@{#1}%
        \let\next=\scanParenBlock@
    \fi
    \next
}


\makeatother
